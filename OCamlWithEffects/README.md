### OCaml with effects

Наш интерпретатор поддерживает базовые конструкции языка OCaml и обработку эффектов.

Поддерживаемые типы: `int`, `bool`, `char`, `string`, `unit`, `list`, `tuple`, `effect`.

Поддерживаемые конструкции: let-привязки, замыкания, арифметические операции, сопоставление с образцом, обработка эффектов, и т.д.

### Effects
Эффекты - это исключения, в момент обработки которых имеется функция, которая вернет значение, которое должно было бы быть вместо бросания исключения, и продолжит исполнение с места бросания исключения.

Объявить эффект можно с помощью ключевого слова `effect`, передав ему аннотацию типа. Эффект может принимать аргумент.
```ocaml
# effect E1 : int effect ;;
val E1 : int effect = <effect>

# effect E2 : int -> int effect ;;
val E2 : int -> int effect = <effect>
```

Вызвать эффект можно при помощи ключевого слова `perform`, передав ему эффект и аругмент (если эффект его принимает).
Для обработки вызванного эффекта используется блок `try with`.

```ocaml
# effect E : int -> int effect
# let result =
    try perform E 0 with
    | (E x) k -> continue k (x + 1)
;;

val E : int -> int effect = <effect>
val result : int = 1
```

Выражения внутри блока `try with` называются обработчиками эффектов. Все они должны в своей левой части "фиксировать" с помощью переменной продолжения место, откуда вызвался эффект. В правой части происходит непосредственно обработка эффекта, которая всегда должна в конечном итоге вызывать `continue k value` - таким образом, продолжая работу с место вызова эффекта. Здесь `value` - значение, которое подставится вместо "бросания" эффекта.

Это работает следующем образом: после `try` располагается любое выражение, внутри которого может быть вызван эффект. Если эффект внутри так и не был вызван, то результат интерпретации этого выражение и есть результат интерпретации блока `try with`. Если вдруг был вызван эффект, то он начинает сопоставляться с описаными в блоке обработчиками эффектов. Если подходящий обработчик не найден - возникнет ошибка, если найден - то в нашем случае "фиксируется" переменная `k`, символизирующая место, откуда вызван эффект и начинается его в обработка. В нашем случае, мы просто продолжаем выполнение, подставив вместо вызова эффекта значение, равное переданному в эффект числа + 1.

Более подробно с примерами обработки эффектов можно ознакомиться в `OCamlWithEffects/demos` и `OCamlWithEffects/tests`.

License: LGPL for implementation code + WTFPL for test examles in miniLanguage

Authors: [Dmitry Pilyuk](https://t.me/DmtrPlk), [Rafik Nurmuhametov](https://t.me/nrrafik)
